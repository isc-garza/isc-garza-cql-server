"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('./messageListeners'),
    NullMessageListener = _require.NullMessageListener;

var _require2 = require('./results'),
    Results = _require2.Results;

var _require3 = require('./context'),
    UnfilteredContext = _require3.UnfilteredContext,
    PatientContext = _require3.PatientContext;

var Executor = /*#__PURE__*/function () {
  function Executor(library, codeService, parameters) {
    var messageListener = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new NullMessageListener();

    _classCallCheck(this, Executor);

    this.library = library;
    this.codeService = codeService;
    this.parameters = parameters;
    this.messageListener = messageListener;
  }

  _createClass(Executor, [{
    key: "withLibrary",
    value: function withLibrary(lib) {
      this.library = lib;
      return this;
    }
  }, {
    key: "withParameters",
    value: function withParameters(params) {
      this.parameters = params != null ? params : {};
      return this;
    }
  }, {
    key: "withCodeService",
    value: function withCodeService(cs) {
      this.codeService = cs;
      return this;
    }
  }, {
    key: "withMessageListener",
    value: function withMessageListener(ml) {
      this.messageListener = ml;
      return this;
    }
  }, {
    key: "exec_expression",
    value: function exec_expression(expression, patientSource, executionDateTime) {
      var r = new Results();
      var expr = this.library.expressions[expression];

      if (expr != null) {
        while (patientSource.currentPatient()) {
          var patient_ctx = new PatientContext(this.library, patientSource.currentPatient(), this.codeService, this.parameters, executionDateTime, this.messageListener);
          r.recordPatientResults(patient_ctx, _defineProperty({}, expression, expr.execute(patient_ctx)));
          patientSource.nextPatient();
        }
      }

      return r;
    }
  }, {
    key: "exec",
    value: function exec(patientSource, executionDateTime) {
      var r = this.exec_patient_context(patientSource, executionDateTime);
      var unfilteredContext = new UnfilteredContext(this.library, r, this.codeService, this.parameters, executionDateTime, this.messageListener);
      var resultMap = {};

      for (var key in this.library.expressions) {
        var expr = this.library.expressions[key];

        if (expr.context === 'Unfiltered') {
          resultMap[key] = expr.exec(unfilteredContext);
        }
      }

      r.recordUnfilteredResults(resultMap);
      return r;
    }
  }, {
    key: "exec_patient_context",
    value: function exec_patient_context(patientSource, executionDateTime) {
      var r = new Results();

      while (patientSource.currentPatient()) {
        var patient_ctx = new PatientContext(this.library, patientSource.currentPatient(), this.codeService, this.parameters, executionDateTime, this.messageListener);
        var resultMap = {};

        for (var key in this.library.expressions) {
          var expr = this.library.expressions[key];

          if (expr.context === 'Patient') {
            resultMap[key] = expr.execute(patient_ctx);
          }
        }

        r.recordPatientResults(patient_ctx, resultMap);
        patientSource.nextPatient();
      }

      return r;
    }
  }]);

  return Executor;
}();

module.exports = {
  Executor: Executor
};